"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

var _Utilities = require("../Utilities");

var _SpinalNodePointer = _interopRequireDefault(require("../SpinalNodePointer"));

var _SpinalRelationFactory = require("../Relations/SpinalRelationFactory");

var _SpinalMap = _interopRequireDefault(require("../SpinalMap"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const globalType = typeof window === "undefined" ? global : window;

class SpinalNode extends globalType.Model {
  /**
   *
   * @param type of the spinalNode default SpinalNode
   * @param element optional element pointed by the node by default setElement to a new empty new Model
   */
  constructor(type = "SpinalNode", element = new globalType.Model()) {
    super();
    this.add_attr({
      info: {
        id: (0, _Utilities.guid)(this.constructor.name),
        type: type
      },
      //contain a list of SpinalRelationRef {relationName: Lst}
      relationListTypeSpinalRelation: new _SpinalMap.default(),
      //contain a list of SpinalRelationLstPtr {relationName: Lst}
      relationListTypeSpinalRelationLstPtr: new _SpinalMap.default(),
      //contain a list of SpinalRelationPtrLst {relationName: Lst}
      relationListTypeSpinalRelationPtrLst: new _SpinalMap.default(),
      //SpinalMap<String, Pointer>
      parents: new _SpinalMap.default(),
      //
      element: new _SpinalNodePointer.default(element),
      _relationTypesLst: [_SpinalRelationFactory.SPINAL_RELATION_TYPE, _SpinalRelationFactory.SPINAL_RELATION_LST_PTR_TYPE, _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE]
    });
  }
  /**
   * Shortcut to info.id
   * @return {Str}
   */


  getId() {
    return this.info.id;
  }
  /**
   * Return the element
   * @return a promise where the parameter of the resolve method is the element.
   */


  getElement() {
    return (0, _Utilities.promiseLoad)(this.element);
  }
  /**
   * Shortcut to info.type
   * @return {Str} type of the node.
   */


  getType() {
    return this.info.type;
  }
  /**
   * Verify if the node contain the relation name @param relationName
   * @param relationName {string} name of the relation.
   * @param relationType {int} relation type
   * @return {Boolean} return true is the relation is contain in the node false otherwise.
   */


  hasRelation(relationName, relationType) {
    return this._getRelationListType(relationType).has(relationName);
  }
  /**
   * Verify if the node contain all the relation name contain @param relationName
   * @param relationNames {array} Array containing all the relation name
   * @param relationType {int} relation type
   * @return {Boolean} return true if the node contain all the relations contain in relationNames false otherwise.
   */


  hasRelations(relationNames, relationType) {
    let res = true;

    for (let i = 0; i < relationNames.length && res; i++) {
      res = this.hasRelation(relationNames[i], relationType);
    }

    return res;
  }
  /**
   * Add the @param as child of the relation
   * @param child {SpinalNode | Model} element to add as child
   * @param relationName {string} name of the relation
   * @param relationType {int} type of the relation
   * @return {Str}
   */


  addChild(child, relationName, relationType) {
    if (child instanceof SpinalNode) {
      return this._addToRelation(child, relationName, relationType);
    } else if (child instanceof globalType.Model) {
      return this._createNodeAndAddChildToRelation(child, relationName, relationType);
    }

    throw new Error("Cannot add a child witch is not an instance of SpinalNode or Model.");
  }
  /**
   * Remove the node from the relation children.
   * @param {SpinalNode} node
   * @param {String} relationName
   * @param {Number} relationType
   */


  removeChild(node, relationName, relationType) {
    if (this._getRelationListType(relationType).has(relationName)) {
      let rel = this._getRelationListType(relationType).getElement(relationName);

      return rel.removeChild(node);
    }

    return false;
  }
  /**
   * Remove the node from the graph i.e remove the node from all the parent relation and remove all the children relation
   * this operation might also delete all the sub-graph under this node.
   * After this operation the node can be deleted without fear.
   */


  removeFromGraph() {
    this._removeFromParents();

    this._removeFromChildren();
  }
  /**
   * Return all children for the relation name no matter the type of relation
   * @param relationNames {Array} containing the relation name of the desired children
   * @return {Promise<Array | never | void>} containing all children for the relation name. The array might be empty
   */


  getChildren(relationNames) {
    if (relationNames.length > 0) {
      const promises = [];

      for (let i = 0; i < this._relationTypesLst.length; i++) {
        const relationMap = this._getRelationListType(this._relationTypesLst[i].get());

        for (let j = 0; j < relationNames.length; j++) {
          if (relationMap.has(relationNames[j])) {
            const relation = relationMap.getElement(relationNames[j]);
            if (typeof relation.getChildren === 'function') promises.push(relation.getChildren());else //TODO implement SpinalError
              console.error(relation);
          }
        }
      }

      return Promise.all(promises).then(childrenLst => {
        const res = [];

        for (let i = 0; i < childrenLst.length; i++) {
          for (let j = 0; j < childrenLst[i].length; j++) {
            res.push(childrenLst[i][j]);
          }
        }

        return res;
      });
    } else {
      return Promise.resolve(this._getAllChildren());
    }
  }
  /**
   * Return all parents for the relation name no matter the type of relation
   * @param relationNames {Array} containing the relation name of the desired parents
   * @return {Array} containing all parents for the relation name. The array might be empty
   */


  getParent(relationNames) {
    const parents = [];
    this.parents.forEach(parent => {
      (0, _Utilities.promiseLoad)(parent).then(relation => {
        parents.push(relation.getParent());
      });
    });
    return parents;
  }
  /**
   * This function transforms the relation type lst into an array.
   * @return {Array}
   * @private
   */


  _getRelationTypeArray() {
    const res = [];

    for (let i = 0; i < this._relationTypesLst.length; i++) {
      res.push(this._relationTypesLst[i]);
    }

    return res;
  }
  /**
   * Return the relation list corresponding to the relation type
   * @param relationType Type of the relation
   * @return {SpinalMap} Return the relation list corresponding to the relation type
   * @private
   */


  _getRelationListType(relationType) {
    switch (relationType) {
      case _SpinalRelationFactory.SPINAL_RELATION_TYPE:
        return this.relationListTypeSpinalRelation;

      case _SpinalRelationFactory.SPINAL_RELATION_LST_PTR_TYPE:
        return this.relationListTypeSpinalRelationLstPtr;

      case _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE:
        return this.relationListTypeSpinalRelationPtrLst;

      default:
        throw new Error("Unknown relation type: ".concat(relationType.toString()));
    }
  }
  /**
   * Add a node as child.
   * If this node doesn't have a relation name relationName with the type relationType this method will create it.
   * @param node {SpinalNode} to add as child.
   * @param relationName {String} name of the relation
   * @param relationType {int} type of the relation
   * @return {Str} id of the relation where the node was added as child
   * @private
   */


  _addToRelation(node, relationName, relationType) {
    const addToRelation = spinalNode => {
      const relationLst = spinalNode._getRelationListType(relationType);

      const relation = relationLst.getElement(relationName);
      console.log(relation.addChild);
      relation.addChild(node);

      node._addAsParent(this._getRelationListType(relationType).getElement(relationName));

      return this._getRelationListType(relationType).getElement(relationName).id;
    };

    if (this.hasRelation(relationName, relationType)) {
      addToRelation(this);
    } else {
      this._createRelation(relationName, relationType);

      addToRelation(this);
    }
  }
  /**
   * Remove the node from all parent relation the property parents
   * @private
   */


  _removeFromParents() {
    function removeFromParent(parent) {
      parent.removeChild(this);
    }

    const removeFromParentBinded = removeFromParent.bind(this);
    this.parents.forEach(parent => {
      for (let i = 0; i < parent.length; i++) {
        (0, _Utilities.promiseLoad)(parent[i]).then(removeFromParentBinded);
      }
    });
  }
  /**
   * Add the relation as parent of the node.
   * If the node doesn't contain a parents named liked relation Name create a parent and push the relation.
   * @param relation
   * @private
   */


  _addAsParent(relation) {
    const relationName = relation.getName();

    if (this.parents.has(relationName)) {
      this.parents.getElement(relationName).push(new _SpinalNodePointer.default(relation));
    } else {
      const list = new globalType.Lst();
      list.push(new _SpinalNodePointer.default(relation));
      this.parents.setElement(relationName, list);
    }
  }
  /**
   * Add the node as parent
   * @param node {SpinalNode}
   * @private
   */


  _addParent(node) {
    if (typeof this.parent !== "undefined" && node instanceof SpinalNode) this.parent.push(new _SpinalNodePointer.default());
  }
  /**
   * Create a node which points to the element and add it to the corresponding relation
   * @param {*} element
   * @param {String} relationName
   * @param {Number} relationType
   * @private
   */


  _createNodeAndAddChildToRelation(element, relationName, relationType) {
    const node = new SpinalNode(element);
    return this._addToRelation(node, relationName, relationType);
  }
  /**
   * Create a new relation for this node
   * @param {String} relationName
   * @param {Number} relationType
   * @private
   */


  _createRelation(relationName, relationType) {
    const relation = _SpinalRelationFactory.SpinalRelationFactory.getNewRelation(relationName, relationType); //setElement the node as parent of the relation


    relation.setParent(this);

    this._getRelationListType(relationType).setElement(relationName, relation);
  }
  /**
   * Remove all children relation from the graph.
   * This operation might also delete all the sub-graph under this node.
   * @private
   */


  _removeFromChildren() {
    this.relationListTypeSpinalRelation.forEach(relation => {
      relation.removeFromGraph();
    });
    this.relationListTypeSpinalRelationLstPtr.forEach(relation => {
      relation.removeFromGraph();
    });
    this.relationListTypeSpinalRelationPtrLst.forEach(relation => {
      relation.removeFromGraph();
    });
  }

  _childrenToList(relation) {
    return _asyncToGenerator(function* () {
      const lst = [];
      let childrenLst = yield relation.getChildren();

      for (let i = 0; i < childrenLst.length; i++) {
        lst.push(childrenLst[i]);
      }

      return lst;
    })();
  }
  /**
   * Return all children
   * @return {Array}
   * @private
   */


  _getAllChildren() {
    var _this = this;

    return _asyncToGenerator(function* () {
      let res = [];

      try {
        for (let i = 0; i < _this._relationTypesLst.length; i++) {
          let type = _this._relationTypesLst[i].get();

          let childrenRelationMap = _this._getRelationListType(type);

          let keys = childrenRelationMap.keys();

          for (let j = 0; j < keys.length; j++) {
            let children = yield _this._childrenToList(childrenRelationMap[keys[j]]);
            res.push(...children);
          }
        }
      } catch (e) {
        console.error(e);
      }

      return res;
    })();
  }

}

_spinalCoreConnectorjs.default.register_models([SpinalNode]);

var _default = SpinalNode;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Ob2Rlcy9TcGluYWxOb2RlLmpzIl0sIm5hbWVzIjpbImdsb2JhbFR5cGUiLCJ3aW5kb3ciLCJnbG9iYWwiLCJTcGluYWxOb2RlIiwiTW9kZWwiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJlbGVtZW50IiwiYWRkX2F0dHIiLCJpbmZvIiwiaWQiLCJuYW1lIiwicmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uIiwiU3BpbmFsTWFwIiwicmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uTHN0UHRyIiwicmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uUHRyTHN0IiwicGFyZW50cyIsIlNwaW5hbE5vZGVQb2ludGVyIiwiX3JlbGF0aW9uVHlwZXNMc3QiLCJTUElOQUxfUkVMQVRJT05fVFlQRSIsIlNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUiLCJTUElOQUxfUkVMQVRJT05fUFRSX0xTVF9UWVBFIiwiZ2V0SWQiLCJnZXRFbGVtZW50IiwiZ2V0VHlwZSIsImhhc1JlbGF0aW9uIiwicmVsYXRpb25OYW1lIiwicmVsYXRpb25UeXBlIiwiX2dldFJlbGF0aW9uTGlzdFR5cGUiLCJoYXMiLCJoYXNSZWxhdGlvbnMiLCJyZWxhdGlvbk5hbWVzIiwicmVzIiwiaSIsImxlbmd0aCIsImFkZENoaWxkIiwiY2hpbGQiLCJfYWRkVG9SZWxhdGlvbiIsIl9jcmVhdGVOb2RlQW5kQWRkQ2hpbGRUb1JlbGF0aW9uIiwiRXJyb3IiLCJyZW1vdmVDaGlsZCIsIm5vZGUiLCJyZWwiLCJyZW1vdmVGcm9tR3JhcGgiLCJfcmVtb3ZlRnJvbVBhcmVudHMiLCJfcmVtb3ZlRnJvbUNoaWxkcmVuIiwiZ2V0Q2hpbGRyZW4iLCJwcm9taXNlcyIsInJlbGF0aW9uTWFwIiwiZ2V0IiwiaiIsInJlbGF0aW9uIiwicHVzaCIsImNvbnNvbGUiLCJlcnJvciIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwiY2hpbGRyZW5Mc3QiLCJyZXNvbHZlIiwiX2dldEFsbENoaWxkcmVuIiwiZ2V0UGFyZW50IiwiZm9yRWFjaCIsInBhcmVudCIsIl9nZXRSZWxhdGlvblR5cGVBcnJheSIsImNvbmNhdCIsInRvU3RyaW5nIiwiYWRkVG9SZWxhdGlvbiIsInNwaW5hbE5vZGUiLCJyZWxhdGlvbkxzdCIsImxvZyIsIl9hZGRBc1BhcmVudCIsIl9jcmVhdGVSZWxhdGlvbiIsInJlbW92ZUZyb21QYXJlbnQiLCJyZW1vdmVGcm9tUGFyZW50QmluZGVkIiwiYmluZCIsImdldE5hbWUiLCJsaXN0IiwiTHN0Iiwic2V0RWxlbWVudCIsIl9hZGRQYXJlbnQiLCJTcGluYWxSZWxhdGlvbkZhY3RvcnkiLCJnZXROZXdSZWxhdGlvbiIsInNldFBhcmVudCIsIl9jaGlsZHJlblRvTGlzdCIsImxzdCIsImNoaWxkcmVuUmVsYXRpb25NYXAiLCJrZXlzIiwiY2hpbGRyZW4iLCJlIiwic3BpbmFsQ29yZSIsInJlZ2lzdGVyX21vZGVscyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUlBOztBQU1BOzs7Ozs7OztBQVJBLE1BQU1BLFVBQVUsR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQyxNQUFoQyxHQUF5Q0QsTUFBNUQ7O0FBVUEsTUFBTUUsVUFBTixTQUF5QkgsVUFBVSxDQUFDSSxLQUFwQyxDQUEwQztBQUN0Qzs7Ozs7QUFLQUMsRUFBQUEsV0FBVyxDQUFDQyxJQUFJLEdBQUcsWUFBUixFQUFzQkMsT0FBTyxHQUFHLElBQUlQLFVBQVUsQ0FBQ0ksS0FBZixFQUFoQyxFQUFzRDtBQUM3RDtBQUNBLFNBQUtJLFFBQUwsQ0FBYztBQUNWQyxNQUFBQSxJQUFJLEVBQUU7QUFDRkMsUUFBQUEsRUFBRSxFQUFFLHFCQUFLLEtBQUtMLFdBQUwsQ0FBaUJNLElBQXRCLENBREY7QUFFRkwsUUFBQUEsSUFBSSxFQUFFQTtBQUZKLE9BREk7QUFLVjtBQUNBTSxNQUFBQSw4QkFBOEIsRUFBRSxJQUFJQyxrQkFBSixFQU50QjtBQU9WO0FBQ0FDLE1BQUFBLG9DQUFvQyxF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Q2VBLFUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3BpbmFsQ29yZSBmcm9tIFwic3BpbmFsLWNvcmUtY29ubmVjdG9yanNcIjtcbmltcG9ydCB7IHByb21pc2VMb2FkLCBndWlkIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuaW1wb3J0IFNwaW5hbE5vZGVQb2ludGVyIGZyb20gXCIuLi9TcGluYWxOb2RlUG9pbnRlclwiXG5cbmNvbnN0IGdsb2JhbFR5cGUgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5pbXBvcnQge1xuICAgIFNQSU5BTF9SRUxBVElPTl9UWVBFLFxuICAgIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUsXG4gICAgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSxcbiAgICBTcGluYWxSZWxhdGlvbkZhY3Rvcnlcbn0gZnJvbSBcIi4uL1JlbGF0aW9ucy9TcGluYWxSZWxhdGlvbkZhY3RvcnlcIlxuaW1wb3J0IFNwaW5hbE1hcCBmcm9tIFwiLi4vU3BpbmFsTWFwXCJcblxuY2xhc3MgU3BpbmFsTm9kZSBleHRlbmRzIGdsb2JhbFR5cGUuTW9kZWwge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgb2YgdGhlIHNwaW5hbE5vZGUgZGVmYXVsdCBTcGluYWxOb2RlXG4gICAgICogQHBhcmFtIGVsZW1lbnQgb3B0aW9uYWwgZWxlbWVudCBwb2ludGVkIGJ5IHRoZSBub2RlIGJ5IGRlZmF1bHQgc2V0RWxlbWVudCB0byBhIG5ldyBlbXB0eSBuZXcgTW9kZWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlID0gXCJTcGluYWxOb2RlXCIsIGVsZW1lbnQgPSBuZXcgZ2xvYmFsVHlwZS5Nb2RlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZF9hdHRyKHtcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICBpZDogZ3VpZCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUpLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9jb250YWluIGEgbGlzdCBvZiBTcGluYWxSZWxhdGlvblJlZiB7cmVsYXRpb25OYW1lOiBMc3R9XG4gICAgICAgICAgICByZWxhdGlvbkxpc3RUeXBlU3BpbmFsUmVsYXRpb246IG5ldyBTcGluYWxNYXAoKSxcbiAgICAgICAgICAgIC8vY29udGFpbiBhIGxpc3Qgb2YgU3BpbmFsUmVsYXRpb25Mc3RQdHIge3JlbGF0aW9uTmFtZTogTHN0fVxuICAgICAgICAgICAgcmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uTHN0UHRyOiBuZXcgU3BpbmFsTWFwKCksXG5cbiAgICAgICAgICAgIC8vY29udGFpbiBhIGxpc3Qgb2YgU3BpbmFsUmVsYXRpb25QdHJMc3Qge3JlbGF0aW9uTmFtZTogTHN0fVxuICAgICAgICAgICAgcmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uUHRyTHN0OiBuZXcgU3BpbmFsTWFwKCksXG5cbiAgICAgICAgICAgIC8vU3BpbmFsTWFwPFN0cmluZywgUG9pbnRlcj5cbiAgICAgICAgICAgIHBhcmVudHM6IG5ldyBTcGluYWxNYXAoKSxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBlbGVtZW50OiBuZXcgU3BpbmFsTm9kZVBvaW50ZXIoZWxlbWVudCksXG4gICAgICAgICAgICBfcmVsYXRpb25UeXBlc0xzdDogW1xuICAgICAgICAgICAgICAgIFNQSU5BTF9SRUxBVElPTl9UWVBFLFxuICAgICAgICAgICAgICAgIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUsXG4gICAgICAgICAgICAgICAgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCB0byBpbmZvLmlkXG4gICAgICogQHJldHVybiB7U3RyfVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudFxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHdoZXJlIHRoZSBwYXJhbWV0ZXIgb2YgdGhlIHJlc29sdmUgbWV0aG9kIGlzIHRoZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlTG9hZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IHRvIGluZm8udHlwZVxuICAgICAqIEByZXR1cm4ge1N0cn0gdHlwZSBvZiB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBub2RlIGNvbnRhaW4gdGhlIHJlbGF0aW9uIG5hbWUgQHBhcmFtIHJlbGF0aW9uTmFtZVxuICAgICAqIEBwYXJhbSByZWxhdGlvbk5hbWUge3N0cmluZ30gbmFtZSBvZiB0aGUgcmVsYXRpb24uXG4gICAgICogQHBhcmFtIHJlbGF0aW9uVHlwZSB7aW50fSByZWxhdGlvbiB0eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJuIHRydWUgaXMgdGhlIHJlbGF0aW9uIGlzIGNvbnRhaW4gaW4gdGhlIG5vZGUgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhc1JlbGF0aW9uKHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSZWxhdGlvbkxpc3RUeXBlKHJlbGF0aW9uVHlwZSkuaGFzKHJlbGF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGlmIHRoZSBub2RlIGNvbnRhaW4gYWxsIHRoZSByZWxhdGlvbiBuYW1lIGNvbnRhaW4gQHBhcmFtIHJlbGF0aW9uTmFtZVxuICAgICAqIEBwYXJhbSByZWxhdGlvbk5hbWVzIHthcnJheX0gQXJyYXkgY29udGFpbmluZyBhbGwgdGhlIHJlbGF0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0gcmVsYXRpb25UeXBlIHtpbnR9IHJlbGF0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSByZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBjb250YWluIGFsbCB0aGUgcmVsYXRpb25zIGNvbnRhaW4gaW4gcmVsYXRpb25OYW1lcyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzUmVsYXRpb25zKHJlbGF0aW9uTmFtZXMsIHJlbGF0aW9uVHlwZSkge1xuICAgICAgICBsZXQgcmVzID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbGF0aW9uTmFtZXMubGVuZ3RoICYmIHJlczsgaSsrKSB7XG4gICAgICAgICAgICByZXMgPSB0aGlzLmhhc1JlbGF0aW9uKHJlbGF0aW9uTmFtZXNbaV0sIHJlbGF0aW9uVHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBAcGFyYW0gYXMgY2hpbGQgb2YgdGhlIHJlbGF0aW9uXG4gICAgICogQHBhcmFtIGNoaWxkIHtTcGluYWxOb2RlIHwgTW9kZWx9IGVsZW1lbnQgdG8gYWRkIGFzIGNoaWxkXG4gICAgICogQHBhcmFtIHJlbGF0aW9uTmFtZSB7c3RyaW5nfSBuYW1lIG9mIHRoZSByZWxhdGlvblxuICAgICAqIEBwYXJhbSByZWxhdGlvblR5cGUge2ludH0gdHlwZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJ9XG4gICAgICovXG4gICAgYWRkQ2hpbGQoY2hpbGQsIHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgU3BpbmFsTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUmVsYXRpb24oY2hpbGQsIHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIGdsb2JhbFR5cGUuTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVOb2RlQW5kQWRkQ2hpbGRUb1JlbGF0aW9uKGNoaWxkLCByZWxhdGlvbk5hbWUsIHJlbGF0aW9uVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGEgY2hpbGQgd2l0Y2ggaXMgbm90IGFuIGluc3RhbmNlIG9mIFNwaW5hbE5vZGUgb3IgTW9kZWwuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSByZWxhdGlvbiBjaGlsZHJlbi5cbiAgICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpb25OYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF0aW9uVHlwZVxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkKG5vZGUsIHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRSZWxhdGlvbkxpc3RUeXBlKHJlbGF0aW9uVHlwZSkuaGFzKHJlbGF0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCByZWwgPSB0aGlzLl9nZXRSZWxhdGlvbkxpc3RUeXBlKHJlbGF0aW9uVHlwZSkuZ2V0RWxlbWVudChyZWxhdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgZ3JhcGggaS5lIHJlbW92ZSB0aGUgbm9kZSBmcm9tIGFsbCB0aGUgcGFyZW50IHJlbGF0aW9uIGFuZCByZW1vdmUgYWxsIHRoZSBjaGlsZHJlbiByZWxhdGlvblxuICAgICAqIHRoaXMgb3BlcmF0aW9uIG1pZ2h0IGFsc28gZGVsZXRlIGFsbCB0aGUgc3ViLWdyYXBoIHVuZGVyIHRoaXMgbm9kZS5cbiAgICAgKiBBZnRlciB0aGlzIG9wZXJhdGlvbiB0aGUgbm9kZSBjYW4gYmUgZGVsZXRlZCB3aXRob3V0IGZlYXIuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUdyYXBoKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50cygpO1xuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tQ2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGNoaWxkcmVuIGZvciB0aGUgcmVsYXRpb24gbmFtZSBubyBtYXR0ZXIgdGhlIHR5cGUgb2YgcmVsYXRpb25cbiAgICAgKiBAcGFyYW0gcmVsYXRpb25OYW1lcyB7QXJyYXl9IGNvbnRhaW5pbmcgdGhlIHJlbGF0aW9uIG5hbWUgb2YgdGhlIGRlc2lyZWQgY2hpbGRyZW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5IHwgbmV2ZXIgfCB2b2lkPn0gY29udGFpbmluZyBhbGwgY2hpbGRyZW4gZm9yIHRoZSByZWxhdGlvbiBuYW1lLiBUaGUgYXJyYXkgbWlnaHQgYmUgZW1wdHlcbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbihyZWxhdGlvbk5hbWVzKSB7XG4gICAgICAgIGlmIChyZWxhdGlvbk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3JlbGF0aW9uVHlwZXNMc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGlvbk1hcCA9IHRoaXMuX2dldFJlbGF0aW9uTGlzdFR5cGUodGhpcy5fcmVsYXRpb25UeXBlc0xzdFtpXS5nZXQoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWxhdGlvbk5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvbk1hcC5oYXMocmVsYXRpb25OYW1lc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aW9uID0gcmVsYXRpb25NYXAuZ2V0RWxlbWVudChyZWxhdGlvbk5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVsYXRpb24uZ2V0Q2hpbGRyZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChyZWxhdGlvbi5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gaW1wbGVtZW50IFNwaW5hbEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZWxhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oY2hpbGRyZW5Mc3QgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuTHN0W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChjaGlsZHJlbkxzdFtpXVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2dldEFsbENoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCBwYXJlbnRzIGZvciB0aGUgcmVsYXRpb24gbmFtZSBubyBtYXR0ZXIgdGhlIHR5cGUgb2YgcmVsYXRpb25cbiAgICAgKiBAcGFyYW0gcmVsYXRpb25OYW1lcyB7QXJyYXl9IGNvbnRhaW5pbmcgdGhlIHJlbGF0aW9uIG5hbWUgb2YgdGhlIGRlc2lyZWQgcGFyZW50c1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBjb250YWluaW5nIGFsbCBwYXJlbnRzIGZvciB0aGUgcmVsYXRpb24gbmFtZS4gVGhlIGFycmF5IG1pZ2h0IGJlIGVtcHR5XG4gICAgICovXG4gICAgZ2V0UGFyZW50KHJlbGF0aW9uTmFtZXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuXG4gICAgICAgIHRoaXMucGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICAgICAgICBwcm9taXNlTG9hZChwYXJlbnQpLnRoZW4ocmVsYXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChyZWxhdGlvbi5nZXRQYXJlbnQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cmFuc2Zvcm1zIHRoZSByZWxhdGlvbiB0eXBlIGxzdCBpbnRvIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlbGF0aW9uVHlwZUFycmF5KCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3JlbGF0aW9uVHlwZXNMc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuX3JlbGF0aW9uVHlwZXNMc3RbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJlbGF0aW9uIGxpc3QgY29ycmVzcG9uZGluZyB0byB0aGUgcmVsYXRpb24gdHlwZVxuICAgICAqIEBwYXJhbSByZWxhdGlvblR5cGUgVHlwZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtTcGluYWxNYXB9IFJldHVybiB0aGUgcmVsYXRpb24gbGlzdCBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWxhdGlvbiB0eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UmVsYXRpb25MaXN0VHlwZShyZWxhdGlvblR5cGUpIHtcbiAgICAgICAgc3dpdGNoIChyZWxhdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU1BJTkFMX1JFTEFUSU9OX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uO1xuXG4gICAgICAgICAgICBjYXNlIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uTHN0UHRyO1xuXG4gICAgICAgICAgICBjYXNlIFNQSU5BTF9SRUxBVElPTl9QVFJfTFNUX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uUHRyTHN0O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcmVsYXRpb24gdHlwZTogXCIuY29uY2F0KHJlbGF0aW9uVHlwZS50b1N0cmluZygpKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgYXMgY2hpbGQuXG4gICAgICogSWYgdGhpcyBub2RlIGRvZXNuJ3QgaGF2ZSBhIHJlbGF0aW9uIG5hbWUgcmVsYXRpb25OYW1lIHdpdGggdGhlIHR5cGUgcmVsYXRpb25UeXBlIHRoaXMgbWV0aG9kIHdpbGwgY3JlYXRlIGl0LlxuICAgICAqIEBwYXJhbSBub2RlIHtTcGluYWxOb2RlfSB0byBhZGQgYXMgY2hpbGQuXG4gICAgICogQHBhcmFtIHJlbGF0aW9uTmFtZSB7U3RyaW5nfSBuYW1lIG9mIHRoZSByZWxhdGlvblxuICAgICAqIEBwYXJhbSByZWxhdGlvblR5cGUge2ludH0gdHlwZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJ9IGlkIG9mIHRoZSByZWxhdGlvbiB3aGVyZSB0aGUgbm9kZSB3YXMgYWRkZWQgYXMgY2hpbGRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRUb1JlbGF0aW9uKG5vZGUsIHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG4gICAgICAgIGNvbnN0IGFkZFRvUmVsYXRpb24gPSAoc3BpbmFsTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpb25Mc3QgPSBzcGluYWxOb2RlLl9nZXRSZWxhdGlvbkxpc3RUeXBlKHJlbGF0aW9uVHlwZSk7XG4gICAgICAgICAgICBjb25zdCByZWxhdGlvbiA9IHJlbGF0aW9uTHN0LmdldEVsZW1lbnQocmVsYXRpb25OYW1lKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlbGF0aW9uLmFkZENoaWxkKTtcbiAgICAgICAgICAgIHJlbGF0aW9uLmFkZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZS5fYWRkQXNQYXJlbnQodGhpcy5fZ2V0UmVsYXRpb25MaXN0VHlwZShyZWxhdGlvblR5cGUpLmdldEVsZW1lbnQocmVsYXRpb25OYW1lKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVsYXRpb25MaXN0VHlwZShyZWxhdGlvblR5cGUpLmdldEVsZW1lbnQocmVsYXRpb25OYW1lKS5pZDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5oYXNSZWxhdGlvbihyZWxhdGlvbk5hbWUsIHJlbGF0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgIGFkZFRvUmVsYXRpb24odGhpcylcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlbGF0aW9uKHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKTtcbiAgICAgICAgICAgIGFkZFRvUmVsYXRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIG5vZGUgZnJvbSBhbGwgcGFyZW50IHJlbGF0aW9uIHRoZSBwcm9wZXJ0eSBwYXJlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRnJvbVBhcmVudHMoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUZyb21QYXJlbnQocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW1vdmVGcm9tUGFyZW50QmluZGVkID0gcmVtb3ZlRnJvbVBhcmVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudHMuZm9yRWFjaCgocGFyZW50KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb21pc2VMb2FkKHBhcmVudFtpXSkudGhlbihyZW1vdmVGcm9tUGFyZW50QmluZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZWxhdGlvbiBhcyBwYXJlbnQgb2YgdGhlIG5vZGUuXG4gICAgICogSWYgdGhlIG5vZGUgZG9lc24ndCBjb250YWluIGEgcGFyZW50cyBuYW1lZCBsaWtlZCByZWxhdGlvbiBOYW1lIGNyZWF0ZSBhIHBhcmVudCBhbmQgcHVzaCB0aGUgcmVsYXRpb24uXG4gICAgICogQHBhcmFtIHJlbGF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQXNQYXJlbnQocmVsYXRpb24pIHtcbiAgICAgICAgY29uc3QgcmVsYXRpb25OYW1lID0gcmVsYXRpb24uZ2V0TmFtZSgpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRzLmhhcyhyZWxhdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudHMuZ2V0RWxlbWVudChyZWxhdGlvbk5hbWUpLnB1c2gobmV3IFNwaW5hbE5vZGVQb2ludGVyKHJlbGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gbmV3IGdsb2JhbFR5cGUuTHN0KCk7XG4gICAgICAgICAgICBsaXN0LnB1c2gobmV3IFNwaW5hbE5vZGVQb2ludGVyKHJlbGF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudHMuc2V0RWxlbWVudChyZWxhdGlvbk5hbWUsIGxpc3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBub2RlIGFzIHBhcmVudFxuICAgICAqIEBwYXJhbSBub2RlIHtTcGluYWxOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZFBhcmVudChub2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgbm9kZSBpbnN0YW5jZW9mIFNwaW5hbE5vZGUpXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5wdXNoKG5ldyBTcGluYWxOb2RlUG9pbnRlcigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBub2RlIHdoaWNoIHBvaW50cyB0byB0aGUgZWxlbWVudCBhbmQgYWRkIGl0IHRvIHRoZSBjb3JyZXNwb25kaW5nIHJlbGF0aW9uXG4gICAgICogQHBhcmFtIHsqfSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aW9uTmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZWxhdGlvblR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVOb2RlQW5kQWRkQ2hpbGRUb1JlbGF0aW9uKGVsZW1lbnQsIHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU3BpbmFsTm9kZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUmVsYXRpb24obm9kZSwgcmVsYXRpb25OYW1lLCByZWxhdGlvblR5cGUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlbGF0aW9uIGZvciB0aGlzIG5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpb25OYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlbGF0aW9uVHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVJlbGF0aW9uKHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aW9uID0gU3BpbmFsUmVsYXRpb25GYWN0b3J5LmdldE5ld1JlbGF0aW9uKHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKTtcbiAgICAgICAgLy9zZXRFbGVtZW50IHRoZSBub2RlIGFzIHBhcmVudCBvZiB0aGUgcmVsYXRpb25cbiAgICAgICAgcmVsYXRpb24uc2V0UGFyZW50KHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2dldFJlbGF0aW9uTGlzdFR5cGUocmVsYXRpb25UeXBlKS5zZXRFbGVtZW50KHJlbGF0aW9uTmFtZSwgcmVsYXRpb24pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjaGlsZHJlbiByZWxhdGlvbiBmcm9tIHRoZSBncmFwaC5cbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBtaWdodCBhbHNvIGRlbGV0ZSBhbGwgdGhlIHN1Yi1ncmFwaCB1bmRlciB0aGlzIG5vZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRnJvbUNoaWxkcmVuKCkge1xuICAgICAgICB0aGlzLnJlbGF0aW9uTGlzdFR5cGVTcGluYWxSZWxhdGlvbi5mb3JFYWNoKHJlbGF0aW9uID0+IHtcbiAgICAgICAgICAgIHJlbGF0aW9uLnJlbW92ZUZyb21HcmFwaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWxhdGlvbkxpc3RUeXBlU3BpbmFsUmVsYXRpb25Mc3RQdHIuZm9yRWFjaChyZWxhdGlvbiA9PiB7XG4gICAgICAgICAgICByZWxhdGlvbi5yZW1vdmVGcm9tR3JhcGgoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVsYXRpb25MaXN0VHlwZVNwaW5hbFJlbGF0aW9uUHRyTHN0LmZvckVhY2gocmVsYXRpb24gPT4ge1xuICAgICAgICAgICAgcmVsYXRpb24ucmVtb3ZlRnJvbUdyYXBoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgYXN5bmMgIF9jaGlsZHJlblRvTGlzdChyZWxhdGlvbikge1xuICAgICAgICBjb25zdCBsc3QgPSBbXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuTHN0ID0gYXdhaXQgcmVsYXRpb24uZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbHN0LnB1c2goY2hpbGRyZW5Mc3RbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCBjaGlsZHJlblxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2dldEFsbENoaWxkcmVuKCkge1xuICAgICAgICBsZXQgcmVzID0gW107XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yZWxhdGlvblR5cGVzTHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLl9yZWxhdGlvblR5cGVzTHN0W2ldLmdldCgpO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlblJlbGF0aW9uTWFwID0gdGhpcy5fZ2V0UmVsYXRpb25MaXN0VHlwZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQga2V5cyA9IGNoaWxkcmVuUmVsYXRpb25NYXAua2V5cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBhd2FpdCB0aGlzLl9jaGlsZHJlblRvTGlzdChjaGlsZHJlblJlbGF0aW9uTWFwW2tleXNbal1dKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbnNwaW5hbENvcmUucmVnaXN0ZXJfbW9kZWxzKFtTcGluYWxOb2RlXSk7XG5leHBvcnQgZGVmYXVsdCBTcGluYWxOb2RlO1xuIl19