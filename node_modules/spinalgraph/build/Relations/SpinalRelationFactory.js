"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpinalRelationFactory = exports.SPINAL_RELATION_PTR_LST_TYPE = exports.SPINAL_RELATION_LST_PTR_TYPE = exports.SPINAL_RELATION_TYPE = void 0;

var _SpinalRelationRef = _interopRequireDefault(require("./SpinalRelationRef"));

var _SpinalRelationLstPtr = _interopRequireDefault(require("./SpinalRelationLstPtr"));

var _SpinalRelationPtrLst = _interopRequireDefault(require("./SpinalRelationPtrLst"));

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SPINAL_RELATION_TYPE = 0;
exports.SPINAL_RELATION_TYPE = SPINAL_RELATION_TYPE;
const SPINAL_RELATION_LST_PTR_TYPE = 1;
exports.SPINAL_RELATION_LST_PTR_TYPE = SPINAL_RELATION_LST_PTR_TYPE;
const SPINAL_RELATION_PTR_LST_TYPE = 2;
exports.SPINAL_RELATION_PTR_LST_TYPE = SPINAL_RELATION_PTR_LST_TYPE;

class SpinalRelationFactory {
  constructor() {}
  /**
   * Create a new relation of relationType with the relationName
   * @param relationName {String} name of the relation
   * @param relationType {String} type of the relation
   * @return {SpinalRelationRef|SpinalRelationLstPtr|SpinalRelationPtrLst}
   */


  static getNewRelation(relationName, relationType) {
    let relation;

    switch (relationType) {
      case SPINAL_RELATION_TYPE:
        relation = new _SpinalRelationRef.default(relationName);
        break;

      case SPINAL_RELATION_LST_PTR_TYPE:
        relation = new _SpinalRelationLstPtr.default(relationName);
        break;

      case SPINAL_RELATION_PTR_LST_TYPE:
        relation = new _SpinalRelationPtrLst.default(relationName);
        break;

      default:
        throw new Error("Unknown relationType");
    }

    return relation;
  }

}

exports.SpinalRelationFactory = SpinalRelationFactory;

_spinalCoreConnectorjs.default.register_models([SpinalRelationFactory]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9SZWxhdGlvbnMvU3BpbmFsUmVsYXRpb25GYWN0b3J5LmpzIl0sIm5hbWVzIjpbIlNQSU5BTF9SRUxBVElPTl9UWVBFIiwiU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSIsIlNQSU5BTF9SRUxBVElPTl9QVFJfTFNUX1RZUEUiLCJTcGluYWxSZWxhdGlvbkZhY3RvcnkiLCJjb25zdHJ1Y3RvciIsImdldE5ld1JlbGF0aW9uIiwicmVsYXRpb25OYW1lIiwicmVsYXRpb25UeXBlIiwicmVsYXRpb24iLCJTcGluYWxSZWxhdGlvblJlZiIsIlNwaW5hbFJlbGF0aW9uTHN0UHRyIiwiU3BpbmFsUmVsYXRpb25QdHJMc3QiLCJFcnJvciIsInNwaW5hbENvcmUiLCJyZWdpc3Rlcl9tb2RlbHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBLE1BQU1BLG9CQUFvQixHQUFHLENBQTdCOztBQUNBLE1BQU1DLDRCQUE0QixHQUFHLENBQXJDOztBQUNBLE1BQU1DLDRCQUE0QixHQUFHLENBQXJDOzs7QUFFQSxNQUFNQyxxQkFBTixDQUE0QjtBQUN4QkMsRUFBQUEsV0FBVyxHQUFHLENBRWI7QUFFRDs7Ozs7Ozs7QUFNQSxTQUFPQyxjQUFQLENBQXNCQyxZQUF0QixFQUFvQ0MsWUFBcEMsRUFBa0Q7QUFFOUMsUUFBSUMsUUFBSjs7QUFDQSxZQUFRRCxZQUFSO0FBQ0ksV0FBS1Asb0JBQUw7QUFDSVEsUUFBQUEsUUFBUSxHQUFHLElBQUlDLDBCQUFKLENBQXNCSCxZQUF0QixDQUFYO0FBQ0E7O0FBQ0osV0FBS0wsNEJBQUw7QUFDSU8sUUFBQUEsUUFBUSxHQUFHLElBQUlFLDZCQUFKLENBQXlCSixZQUF6QixDQUFYO0FBQ0E7O0FBQ0osV0FBS0osNEJBQUw7QUFDSU0sUUFBQUEsUUFBUSxHQUFHLElBQUlHLDZCQUFKLENBQXlCTCxZQUF6QixDQUFYO0FBQ0E7O0FBQ0o7QUFDSSxjQUFNLElBQUlNLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBWFI7O0FBY0EsV0FBT0osUUFBUDtBQUNIOztBQTdCdUI7Ozs7QUFnQzVCSywrQkFBV0MsZUFBWCxDQUEyQixDQUFDWCxxQkFBRCxDQUEzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTcGluYWxSZWxhdGlvblJlZiBmcm9tIFwiLi9TcGluYWxSZWxhdGlvblJlZlwiO1xuaW1wb3J0IFNwaW5hbFJlbGF0aW9uTHN0UHRyIGZyb20gXCIuL1NwaW5hbFJlbGF0aW9uTHN0UHRyXCJcbmltcG9ydCBTcGluYWxSZWxhdGlvblB0ckxzdCBmcm9tIFwiLi9TcGluYWxSZWxhdGlvblB0ckxzdFwiXG5pbXBvcnQgc3BpbmFsQ29yZSBmcm9tIFwic3BpbmFsLWNvcmUtY29ubmVjdG9yanNcIjtcbmNvbnN0IFNQSU5BTF9SRUxBVElPTl9UWVBFID0gMDtcbmNvbnN0IFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUgPSAxO1xuY29uc3QgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSA9IDI7XG5cbmNsYXNzIFNwaW5hbFJlbGF0aW9uRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmVsYXRpb24gb2YgcmVsYXRpb25UeXBlIHdpdGggdGhlIHJlbGF0aW9uTmFtZVxuICAgICAqIEBwYXJhbSByZWxhdGlvbk5hbWUge1N0cmluZ30gbmFtZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcGFyYW0gcmVsYXRpb25UeXBlIHtTdHJpbmd9IHR5cGUgb2YgdGhlIHJlbGF0aW9uXG4gICAgICogQHJldHVybiB7U3BpbmFsUmVsYXRpb25SZWZ8U3BpbmFsUmVsYXRpb25Mc3RQdHJ8U3BpbmFsUmVsYXRpb25QdHJMc3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldE5ld1JlbGF0aW9uKHJlbGF0aW9uTmFtZSwgcmVsYXRpb25UeXBlKSB7XG5cbiAgICAgICAgbGV0IHJlbGF0aW9uO1xuICAgICAgICBzd2l0Y2ggKHJlbGF0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTUElOQUxfUkVMQVRJT05fVFlQRTpcbiAgICAgICAgICAgICAgICByZWxhdGlvbiA9IG5ldyBTcGluYWxSZWxhdGlvblJlZihyZWxhdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTUElOQUxfUkVMQVRJT05fTFNUX1BUUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJlbGF0aW9uID0gbmV3IFNwaW5hbFJlbGF0aW9uTHN0UHRyKHJlbGF0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNQSU5BTF9SRUxBVElPTl9QVFJfTFNUX1RZUEU6XG4gICAgICAgICAgICAgICAgcmVsYXRpb24gPSBuZXcgU3BpbmFsUmVsYXRpb25QdHJMc3QocmVsYXRpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByZWxhdGlvblR5cGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVsYXRpb247XG4gICAgfVxufVxuXG5zcGluYWxDb3JlLnJlZ2lzdGVyX21vZGVscyhbU3BpbmFsUmVsYXRpb25GYWN0b3J5XSk7XG5leHBvcnQge1xuICAgIFNQSU5BTF9SRUxBVElPTl9UWVBFLFxuICAgIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUsXG4gICAgU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSxcbiAgICBTcGluYWxSZWxhdGlvbkZhY3Rvcnlcbn1cbiJdfQ==