"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseSpinalRelation = _interopRequireDefault(require("./BaseSpinalRelation"));

var _SpinalRelationFactory = require("./SpinalRelationFactory");

var _SpinalNode = _interopRequireDefault(require("../Nodes/SpinalNode"));

var _Utilities = require("../Utilities");

var _SpinalNodePointer = _interopRequireDefault(require("../SpinalNodePointer"));

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const globalType = typeof window === "undefined" ? global : window;

class SpinalRelationLstPtr extends _BaseSpinalRelation.default {
  constructor(name) {
    super(name);
    this.add_attr({
      children: new globalType.Lst()
    });
  }
  /**
   * This function retrieve all the id from children of the relation and return them inside an array.
   * @return {Array} containing all the children Id of the relation
   */


  getChildrenIds() {
    const res = [];

    for (let i = 0; i < this.children.length; i++) {
      res.push(this.children[i].getId());
    }

    return res;
  }
  /**
   * Return all the children of the relation
   * @return {Promise<globalType.Lst>}
   */


  getChildren() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const promiseList = [];

      for (let i = 0; i < _this.children.length; i++) {
        let ptr = _this.children[i];
        promiseList.push((0, _Utilities.promiseLoad)(ptr));
      }

      const children = new globalType.Lst();
      yield Promise.all(promiseList).then(values => {
        for (let i = 0; i < values.length; i++) {
          children.push(values[i]);
        }
      });
      return Promise.resolve(children);
    })();
  }
  /**
   * Returns the type of the relation
   * @return {Number} Type of the relation
   */


  getType() {
    return _SpinalRelationFactory.SPINAL_RELATION_LST_PTR_TYPE;
  }
  /**
   * Adds node as child of the relation. If the node is a model, creates a node.
   * @param node {SpinalNode | globalType.Model}
   */


  addChild(node) {
    if (node instanceof _SpinalNode.default) {
      this.children.push(new _SpinalNodePointer.default(node));
      this.getParent().then(parent => {
        if (typeof parent !== "undefined" && parent instanceof _SpinalNode.default) node._addParent(parent);
      });
    } else if (node instanceof globalType.Model) {
      const tmpNode = new _SpinalNode.default(this.name, node);
      this.addChild(tmpNode);
    }
  }
  /**
   * Removes a child from the relation.
   * @param {SpinalNode | Model} node Node to be removed 
   * @return {Boolean} true if the child has been successfully removed, false otherwise
   */


  removeChild(node) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      for (let i = 0; i < _this2.children.length; i++) {
        if (_this2.children[i].info.pointed_id === node.id) {
          let ptr = _this2.children[i];

          _this2.children.remove(ptr);
        }
      }

      return _this2.children.indexOf(node) === -1;
    })();
  }

}

_spinalCoreConnectorjs.default.register_models([SpinalRelationLstPtr]);

var _default = SpinalRelationLstPtr;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9SZWxhdGlvbnMvU3BpbmFsUmVsYXRpb25Mc3RQdHIuanMiXSwibmFtZXMiOlsiZ2xvYmFsVHlwZSIsIndpbmRvdyIsImdsb2JhbCIsIlNwaW5hbFJlbGF0aW9uTHN0UHRyIiwiQmFzZVNwaW5hbFJlbGF0aW9uIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWRkX2F0dHIiLCJjaGlsZHJlbiIsIkxzdCIsImdldENoaWxkcmVuSWRzIiwicmVzIiwiaSIsImxlbmd0aCIsInB1c2giLCJnZXRJZCIsImdldENoaWxkcmVuIiwicHJvbWlzZUxpc3QiLCJwdHIiLCJQcm9taXNlIiwiYWxsIiwidGhlbiIsInZhbHVlcyIsInJlc29sdmUiLCJnZXRUeXBlIiwiU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSIsImFkZENoaWxkIiwibm9kZSIsIlNwaW5hbE5vZGUiLCJTcGluYWxOb2RlUG9pbnRlciIsImdldFBhcmVudCIsInBhcmVudCIsIl9hZGRQYXJlbnQiLCJNb2RlbCIsInRtcE5vZGUiLCJyZW1vdmVDaGlsZCIsImluZm8iLCJwb2ludGVkX2lkIiwiaWQiLCJyZW1vdmUiLCJpbmRleE9mIiwic3BpbmFsQ29yZSIsInJlZ2lzdGVyX21vZGVscyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLFVBQVUsR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQyxNQUFoQyxHQUF5Q0QsTUFBNUQ7O0FBRUEsTUFBTUUsb0JBQU4sU0FBbUNDLDJCQUFuQyxDQUFzRDtBQUNsREMsRUFBQUEsV0FBVyxDQUFDQyxJQUFELEVBQU87QUFDZCxVQUFNQSxJQUFOO0FBQ0EsU0FBS0MsUUFBTCxDQUFjO0FBQ1ZDLE1BQUFBLFFBQVEsRUFBRSxJQUFJUixVQUFVLENBQUNTLEdBQWY7QUFEQSxLQUFkO0FBR0g7QUFFRDs7Ozs7O0FBSUFDLEVBQUFBLGNBQWMsR0FBRztBQUNi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QztBQVJvQjtBQVN2Qjs7QUFoRmlEOztBQW1GdERjLCtCQUFXQyxlQUFYLENBQTJCLENBQUN2QyxvQkFBRCxDQUEzQjs7ZUFDZUEsb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZVNwaW5hbFJlbGF0aW9uIGZyb20gXCIuL0Jhc2VTcGluYWxSZWxhdGlvblwiXG5pbXBvcnQgeyBTUElOQUxfUkVMQVRJT05fTFNUX1BUUl9UWVBFIH0gZnJvbSBcIi4vU3BpbmFsUmVsYXRpb25GYWN0b3J5XCJcbmltcG9ydCBTcGluYWxOb2RlIGZyb20gXCIuLi9Ob2Rlcy9TcGluYWxOb2RlXCJcbmltcG9ydCB7IHByb21pc2VMb2FkIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuaW1wb3J0IFNwaW5hbE5vZGVQb2ludGVyIGZyb20gXCIuLi9TcGluYWxOb2RlUG9pbnRlclwiO1xuaW1wb3J0IHNwaW5hbENvcmUgZnJvbSBcInNwaW5hbC1jb3JlLWNvbm5lY3RvcmpzXCI7XG5cbmNvbnN0IGdsb2JhbFR5cGUgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5jbGFzcyBTcGluYWxSZWxhdGlvbkxzdFB0ciBleHRlbmRzIEJhc2VTcGluYWxSZWxhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5hZGRfYXR0cih7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV3IGdsb2JhbFR5cGUuTHN0KClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXRyaWV2ZSBhbGwgdGhlIGlkIGZyb20gY2hpbGRyZW4gb2YgdGhlIHJlbGF0aW9uIGFuZCByZXR1cm4gdGhlbSBpbnNpZGUgYW4gYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IGNvbnRhaW5pbmcgYWxsIHRoZSBjaGlsZHJlbiBJZCBvZiB0aGUgcmVsYXRpb25cbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbklkcygpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2godGhpcy5jaGlsZHJlbltpXS5nZXRJZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSByZWxhdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Z2xvYmFsVHlwZS5Mc3Q+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldENoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwdHIgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgcHJvbWlzZUxpc3QucHVzaChwcm9taXNlTG9hZChwdHIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5ldyBnbG9iYWxUeXBlLkxzdCgpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlTGlzdCkudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFR5cGUgb2YgdGhlIHJlbGF0aW9uXG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBub2RlIGFzIGNoaWxkIG9mIHRoZSByZWxhdGlvbi4gSWYgdGhlIG5vZGUgaXMgYSBtb2RlbCwgY3JlYXRlcyBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUge1NwaW5hbE5vZGUgfCBnbG9iYWxUeXBlLk1vZGVsfVxuICAgICAqL1xuICAgIGFkZENoaWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGluYWxOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobmV3IFNwaW5hbE5vZGVQb2ludGVyKG5vZGUpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0UGFyZW50KCkudGhlbihwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHBhcmVudCBpbnN0YW5jZW9mIFNwaW5hbE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2FkZFBhcmVudChwYXJlbnQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBnbG9iYWxUeXBlLk1vZGVsKSB7XG4gICAgICAgICAgICBjb25zdCB0bXBOb2RlID0gbmV3IFNwaW5hbE5vZGUodGhpcy5uYW1lLCBub2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodG1wTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgcmVsYXRpb24uXG4gICAgICogQHBhcmFtIHtTcGluYWxOb2RlIHwgTW9kZWx9IG5vZGUgTm9kZSB0byBiZSByZW1vdmVkIFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNoaWxkIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5pbmZvLnBvaW50ZWRfaWQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHRyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnJlbW92ZShwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmluZGV4T2Yobm9kZSkgPT09IC0xO1xuICAgIH1cbn1cblxuc3BpbmFsQ29yZS5yZWdpc3Rlcl9tb2RlbHMoW1NwaW5hbFJlbGF0aW9uTHN0UHRyXSk7XG5leHBvcnQgZGVmYXVsdCBTcGluYWxSZWxhdGlvbkxzdFB0cjtcbiJdfQ==