"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

var _Utilities = require("../Utilities");

var _SpinalNode = _interopRequireDefault(require("../Nodes/SpinalNode"));

var _SpinalNodePointer = _interopRequireDefault(require("../SpinalNodePointer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const globalType = typeof window === "undefined" ? global : window;

class BaseSpinalRelation extends globalType.Model {
  constructor(name) {
    super();
    this.add_attr({
      id: (0, _Utilities.guid)(name),
      name: name,
      parent: new _SpinalNodePointer.default()
    });
  }
  /**
   * Return the parent of the relation.
   * @return {Promise} return a promise where the resolve function parameter is the parent
   */


  getParent() {
    return (0, _Utilities.promiseLoad)(this.parent);
  }
  /**
   * setElement the parent of the relation. If a parent was already setElement the parent relation is removed.
   * @param parent {SpinalNode}
   */


  setParent(parent) {
    if (typeof parent !== "undefined" && parent instanceof _SpinalNode.default) this.parent.setElement(parent);
  }
  /**
   * Returns the name of the relation
   * @return {Str} Name of the relation
   */


  getName() {
    return this.name;
  }
  /**
   * Returns the type of the relation
   * @return {Number} Type of the relation
   */


  getType() {
    return -1;
  }
  /**
   * Return all the children of the relation
   * @return {Promise<globalType.Lst>}
   */


  getChildren() {
    // noinspection JSValidateTypes
    return Promise.resolve();
  }
  /**
   * Add node as child of the relation if node is a model create a node.
   * @param node {SpinalNode | globalType.Model}
   */


  addChild(node) {}
  /**
   * This function retrieves all the id from children of the relation and return them inside an array.
   * @return {Array} containing all the children Id of the relation
   */


  getChildrenIds() {}
  /**
   * Remove the child from the relation
   * @param node {SpinalNode} child of the relation
   * @return {Promise<boolean>}
   */


  removeChild(node) {
    return _asyncToGenerator(function* () {})();
  }
  /**
   * Removes all children from the relation
   */


  removeChildren() {
    this.getChildren().then(children => {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]).then();
      }
    }).catch(e => {
      console.error("cannot remove child ", e);
    });
  }
  /**
   * Removes the relation from the graph
   */


  removeFromGraph() {
    this._removeFromParent();

    this.removeChildren();
  }
  /**
   * Removes the relation from the parent
   * @private
   */


  _removeFromParent() {
    this.getParent().then(parentNode => {
      let relationMap = parentNode._getRelationListType(this.getType());

      relationMap.delete(this.name.get());
    });
  }

}

_spinalCoreConnectorjs.default.register_models([BaseSpinalRelation]);

var _default = BaseSpinalRelation;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9SZWxhdGlvbnMvQmFzZVNwaW5hbFJlbGF0aW9uLmpzIl0sIm5hbWVzIjpbImdsb2JhbFR5cGUiLCJ3aW5kb3ciLCJnbG9iYWwiLCJCYXNlU3BpbmFsUmVsYXRpb24iLCJNb2RlbCIsImNvbnN0cnVjdG9yIiwibmFtZSIsImFkZF9hdHRyIiwiaWQiLCJwYXJlbnQiLCJTcGluYWxOb2RlUG9pbnRlciIsImdldFBhcmVudCIsInNldFBhcmVudCIsIlNwaW5hbE5vZGUiLCJzZXRFbGVtZW50IiwiZ2V0TmFtZSIsImdldFR5cGUiLCJnZXRDaGlsZHJlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiYWRkQ2hpbGQiLCJub2RlIiwiZ2V0Q2hpbGRyZW5JZHMiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkcmVuIiwidGhlbiIsImNoaWxkcmVuIiwiaSIsImxlbmd0aCIsImNhdGNoIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsInJlbW92ZUZyb21HcmFwaCIsIl9yZW1vdmVGcm9tUGFyZW50IiwicGFyZW50Tm9kZSIsInJlbGF0aW9uTWFwIiwiX2dldFJlbGF0aW9uTGlzdFR5cGUiLCJkZWxldGUiLCJnZXQiLCJzcGluYWxDb3JlIiwicmVnaXN0ZXJfbW9kZWxzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsVUFBVSxHQUFHLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NDLE1BQWhDLEdBQXlDRCxNQUE1RDs7QUFFQSxNQUFNRSxrQkFBTixTQUFpQ0gsVUFBVSxDQUFDSSxLQUE1QyxDQUFrRDtBQUM5Q0MsRUFBQUEsV0FBVyxDQUFDQyxJQUFELEVBQU87QUFDZDtBQUNBLFNBQUtDLFFBQUwsQ0FBYztBQUNWQyxNQUFBQSxFQUFFLEVBQUUscUJBQUtGLElBQUwsQ0FETTtBQUVWQSxNQUFBQSxJQUFJLEVBQUVBLElBRkk7QUFHVkcsTUFBQUEsTUFBTSxFQUFFLElBQUlDLDBCQUFKO0FBSEUsS0FBZDtBQUtIO0FBRUQ7Ozs7OztBQUlBQyxFQUFBQSxTQUFTLEdBQUc7QUFDUixXQUFPLDRCQUFZLEtBQUtGLE1BQWpCLENBQVA7QUFDSDtBQUVEOzs7Ozs7QUFJQUcsRUFBQUEsU0FBUyxDQUFDSCxNQUFELEVBQVM7QUFDZCxRQUFJLE9BQU9BLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE1BQU0sWUFBWUksbUJBQXZELEVBQ0ksS0FBS0osTUFBTCxDQUFZSyxVQUFaLENBQXVCTCxNQUF2QjtBQUNQO0FBRUQ7Ozs7OztBQUlBTSxFQUFBQSxPQUFPLEdBQUc7QUFDTixXQUFPLEtBQUtULElBQVo7QUFDSDtBQUVEOzs7Ozs7QUFJQVUsRUFBQUEsT0FBTyxHQUFHO0FBQ04sV0FBTyxDQUFDLENBQVI7QUFDSDtBQUVEOzs7Ozs7QUFJQUMsRUFBQUEsV0FBVyxHQUFHO0FBQ1Y7QUFDQSxXQUFPQyxPQUFPLENBQUNDLE9BQVIsRUFBUDtBQUNIO0FBRUQ7Ozs7OztBQUlBQyxFQUFBQSxRQUFRLENBQUNDLElBQUQsRUFBTyxDQUVkO0FBRUQ7Ozs7OztBQUlBQyxFQUFBQSxjQUFjLEdBQUcsQ0FFaEI7QUFFRDs7Ozs7OztBQUtNQyxFQUFBQSxXQUFOLENBQWtCRixJQUFsQixFQUF3QjtBQUFBO0FBRXZCO0FBRUQ7Ozs7O0FBR0FHLEVBQUFBLGNBQWMsR0FBRztBQUNiLFNBQUtQLFdBQUwsR0FDS1EsSUFETCxDQUNXQyxRQUFRLElBQUk7QUFDZixXQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELFFBQVEsQ0FBQ0UsTUFBN0IsRUFBcUNELENBQUMsRUFBdEMsRUFBMEM7QUFDdEMsYUFBS0osV0FBTCxDQUFpQkcsUUFBUSxDQUFDQyxDQUFELENBQXpCLEVBQThCRixJQUE5QjtBQUdIO0FBQ1IsS0FQRCxFQVFLSSxLQVJMLENBUVdDLENBQUMsSUFBSTtBQUNSQyxNQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBYyxzQkFBZCxFQUFzQ0YsQ0FBdEM7QUFDSCxLQVZMO0FBV0g7QUFFRDs7Ozs7QUFHQUcsRUFBQUEsZUFBZSxHQUFHO0FBQ2QsU0FBS0MsaUJBQUw7O0FBQ0EsU0FBS1YsY0FBTDtBQUNIO0FBRUQ7Ozs7OztBQUlBVSxFQUFBQSxpQkFBaUIsR0FBRztBQUNoQixTQUFLdkIsU0FBTCxHQUFpQmMsSUFBakIsQ0FBdUJVLFVBQUQsSUFBZ0I7QUFDbEMsVUFBSUMsV0FBVyxHQUFHRCxVQUFVLENBQUNFLG9CQUFYLENBQWdDLEtBQUtyQixPQUFMLEVBQWhDLENBQWxCOztBQUVBb0IsTUFBQUEsV0FBVyxDQUFDRSxNQUFaLENBQW1CLEtBQUtoQyxJQUFMLENBQVVpQyxHQUFWLEVBQW5CO0FBQ0gsS0FKRDtBQUtIOztBQWhINkM7O0FBbUhsREMsK0JBQVdDLGVBQVgsQ0FBMkIsQ0FBQ3RDLGtCQUFELENBQTNCOztlQUNlQSxrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzcGluYWxDb3JlIGZyb20gXCJzcGluYWwtY29yZS1jb25uZWN0b3Jqc1wiO1xuaW1wb3J0IHsgcHJvbWlzZUxvYWQsIGd1aWQgfSBmcm9tIFwiLi4vVXRpbGl0aWVzXCI7XG5pbXBvcnQgU3BpbmFsTm9kZSBmcm9tIFwiLi4vTm9kZXMvU3BpbmFsTm9kZVwiO1xuaW1wb3J0IFNwaW5hbE5vZGVQb2ludGVyIGZyb20gXCIuLi9TcGluYWxOb2RlUG9pbnRlclwiXG5cbmNvbnN0IGdsb2JhbFR5cGUgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5jbGFzcyBCYXNlU3BpbmFsUmVsYXRpb24gZXh0ZW5kcyBnbG9iYWxUeXBlLk1vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWRkX2F0dHIoe1xuICAgICAgICAgICAgaWQ6IGd1aWQobmFtZSksXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgcGFyZW50OiBuZXcgU3BpbmFsTm9kZVBvaW50ZXIoKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFyZW50IG9mIHRoZSByZWxhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSByZXR1cm4gYSBwcm9taXNlIHdoZXJlIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHBhcmFtZXRlciBpcyB0aGUgcGFyZW50XG4gICAgICovXG4gICAgZ2V0UGFyZW50KCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUxvYWQodGhpcy5wYXJlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldEVsZW1lbnQgdGhlIHBhcmVudCBvZiB0aGUgcmVsYXRpb24uIElmIGEgcGFyZW50IHdhcyBhbHJlYWR5IHNldEVsZW1lbnQgdGhlIHBhcmVudCByZWxhdGlvbiBpcyByZW1vdmVkLlxuICAgICAqIEBwYXJhbSBwYXJlbnQge1NwaW5hbE5vZGV9XG4gICAgICovXG4gICAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXJlbnQgaW5zdGFuY2VvZiBTcGluYWxOb2RlKVxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2V0RWxlbWVudChwYXJlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHJlbGF0aW9uXG4gICAgICogQHJldHVybiB7U3RyfSBOYW1lIG9mIHRoZSByZWxhdGlvblxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFR5cGUgb2YgdGhlIHJlbGF0aW9uXG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoZSByZWxhdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Z2xvYmFsVHlwZS5Mc3Q+fVxuICAgICAqL1xuICAgIGdldENoaWxkcmVuKCkge1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNWYWxpZGF0ZVR5cGVzXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbm9kZSBhcyBjaGlsZCBvZiB0aGUgcmVsYXRpb24gaWYgbm9kZSBpcyBhIG1vZGVsIGNyZWF0ZSBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGUge1NwaW5hbE5vZGUgfCBnbG9iYWxUeXBlLk1vZGVsfVxuICAgICAqL1xuICAgIGFkZENoaWxkKG5vZGUpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0cmlldmVzIGFsbCB0aGUgaWQgZnJvbSBjaGlsZHJlbiBvZiB0aGUgcmVsYXRpb24gYW5kIHJldHVybiB0aGVtIGluc2lkZSBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gY29udGFpbmluZyBhbGwgdGhlIGNoaWxkcmVuIElkIG9mIHRoZSByZWxhdGlvblxuICAgICAqL1xuICAgIGdldENoaWxkcmVuSWRzKCkge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIHRoZSByZWxhdGlvblxuICAgICAqIEBwYXJhbSBub2RlIHtTcGluYWxOb2RlfSBjaGlsZCBvZiB0aGUgcmVsYXRpb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUNoaWxkKG5vZGUpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIHJlbGF0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKVxuICAgICAgICAgICAgLnRoZW4oIGNoaWxkcmVuID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGRyZW5baV0pLnRoZW4oXG5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2Fubm90IHJlbW92ZSBjaGlsZCBcIiwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSByZWxhdGlvbiBmcm9tIHRoZSBncmFwaFxuICAgICAqL1xuICAgIHJlbW92ZUZyb21HcmFwaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcmVsYXRpb24gZnJvbSB0aGUgcGFyZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRnJvbVBhcmVudCgpIHtcbiAgICAgICAgdGhpcy5nZXRQYXJlbnQoKS50aGVuKChwYXJlbnROb2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVsYXRpb25NYXAgPSBwYXJlbnROb2RlLl9nZXRSZWxhdGlvbkxpc3RUeXBlKHRoaXMuZ2V0VHlwZSgpKTtcblxuICAgICAgICAgICAgcmVsYXRpb25NYXAuZGVsZXRlKHRoaXMubmFtZS5nZXQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuc3BpbmFsQ29yZS5yZWdpc3Rlcl9tb2RlbHMoW0Jhc2VTcGluYWxSZWxhdGlvbl0pO1xuZXhwb3J0IGRlZmF1bHQgQmFzZVNwaW5hbFJlbGF0aW9uO1xuIl19