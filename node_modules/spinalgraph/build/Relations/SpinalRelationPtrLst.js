"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseSpinalRelation = _interopRequireDefault(require("./BaseSpinalRelation"));

var _SpinalRelationFactory = require("./SpinalRelationFactory");

var _SpinalNode = _interopRequireDefault(require("../Nodes/SpinalNode"));

var _Utilities = require("../Utilities");

var _SpinalNodePointer = _interopRequireDefault(require("../SpinalNodePointer"));

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const globalType = typeof window === "undefined" ? global : window;

class SpinalRelationPtrLst extends _BaseSpinalRelation.default {
  constructor(name) {
    super(name);
    this.add_attr({
      children: new _SpinalNodePointer.default(new globalType.Lst())
    });
    this.children.info.add_attr("ids", []);
  }
  /**
   * This function retrieve all the id from children of the relation and return them inside an array.
   * @return {Array} containing all the children ids of the relation
   */


  getChildrenIds() {
    return this.children.ids;
  }
  /**
   * Return all the children of the relation
   * @return {Promise<globalType.Lst>}
   */


  getChildren() {
    return (0, _Utilities.promiseLoad)(this.children);
  }
  /**
   * Returns the type of the relation
   * @return {Number} Type of the relation
   */


  getType() {
    return _SpinalRelationFactory.SPINAL_RELATION_PTR_LST_TYPE;
  }
  /**
   * Add node as child of the relation if node is a model create a node
   * @param node {SpinalNode | globalType.Model}
   */


  addChild(node) {
    if (node instanceof _SpinalNode.default && !this.children.info.ids.contains(node.getId())) {
      this.children.info.ids.push(node.getId());
      (0, _Utilities.promiseLoad)(this.children).then(children => {
        children.push(node);
      });
      this.getParent().then(parent => {
        node._addParent(parent);
      });
    } else if (node instanceof globalType.Model) {
      const tmpNode = new _SpinalNode.default(this.name, node);
      this.addChild(tmpNode);
    }
  }
  /**
   * Remove the child from the relation
   * @param node {SpinalNode} child of the relation
   * @return {Promise<boolean>}
   */


  removeChild(node) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const childrenLst = yield (0, _Utilities.promiseLoad)(_this.children);
      childrenLst.remove(node);
      return Promise.resolve(childrenLst.indexOf(node) === -1);
    })();
  }

}

_spinalCoreConnectorjs.default.register_models([SpinalRelationPtrLst]);

var _default = SpinalRelationPtrLst;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9SZWxhdGlvbnMvU3BpbmFsUmVsYXRpb25QdHJMc3QuanMiXSwibmFtZXMiOlsiZ2xvYmFsVHlwZSIsIndpbmRvdyIsImdsb2JhbCIsIlNwaW5hbFJlbGF0aW9uUHRyTHN0IiwiQmFzZVNwaW5hbFJlbGF0aW9uIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWRkX2F0dHIiLCJjaGlsZHJlbiIsIlNwaW5hbE5vZGVQb2ludGVyIiwiTHN0IiwiaW5mbyIsImdldENoaWxkcmVuSWRzIiwiaWRzIiwiZ2V0Q2hpbGRyZW4iLCJnZXRUeXBlIiwiU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRSIsImFkZENoaWxkIiwibm9kZSIsIlNwaW5hbE5vZGUiLCJjb250YWlucyIsImdldElkIiwicHVzaCIsInRoZW4iLCJnZXRQYXJlbnQiLCJwYXJlbnQiLCJfYWRkUGFyZW50IiwiTW9kZWwiLCJ0bXBOb2RlIiwicmVtb3ZlQ2hpbGQiLCJjaGlsZHJlbkxzdCIsInJlbW92ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5kZXhPZiIsInNwaW5hbENvcmUiLCJyZWdpc3Rlcl9tb2RlbHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxVQUFVLEdBQUcsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0MsTUFBaEMsR0FBeUNELE1BQTVEOztBQUVBLE1BQU1FLG9CQUFOLFNBQW1DQywyQkFBbkMsQ0FBc0Q7QUFDbERDLEVBQUFBLFdBQVcsQ0FBQ0MsSUFBRCxFQUFPO0FBQ2QsVUFBTUEsSUFBTjtBQUNBLFNBQUtDLFFBQUwsQ0FBYztBQUNWQyxNQUFBQSxRQUFRLEVBQUUsSUFBSUMsMEJBQUosQ0FBc0IsSUFBSVQsVUFBVSxDQUFDVSxHQUFmLEVBQXRCO0FBREEsS0FBZDtBQUlBLFNBQUtGLFFBQUwsQ0FBY0csSUFBZCxDQUFtQkosUUFBbkIsQ0FBNEIsS0FBNUIsRUFBbUMsRUFBbkM7QUFDSDtBQUVEOzs7Ozs7QUFJQUssRUFBQUEsY0FBYyxHQUFHO0FBQ2IsV0FBTyxLQUFLSixRQUFMLENBQWNLLEdBQXJCO0FBQ0g7QUFFRDs7Ozs7O0FBSUFDLEVBQUFBLFdBQVcsR0FBRztBQUNWLFdBQU8sNEJBQVksS0FBS04sUUFBakIsQ0FBUDtBQUNIO0FBRUQ7Ozs7OztBQUlBTyxFQUFBQSxPQUFPLEdBQUc7QUFDTixXQUFPQyxtREFBUDtBQUNIO0FBRUQ7Ozs7OztBQUlBQyxFQUFBQSxRQUFRLENBQUNDLElBQUQsRUFBTztBQUNYLFFBQUlBLElBQUksWUFBWUMsbUJBQWhCLElBQThCLENBQUMsS0FBS1gsUUFBTCxDQUFjRyxJQUFkLENBQW1CRSxHQUFuQixDQUF1Qk8sUUFBdkIsQ0FBZ0NGLElBQUksQ0FBQ0csS0FBTCxFQUFoQyxDQUFuQyxFQUFrRjtBQUM5RSxXQUFLYixRQUFMLENBQWNHLElBQWQsQ0FBbUJFLEdBQW5CLENBQXVCUyxJQUF2QixDQUE0QkosSUFBSSxDQUFDRyxLQUFMLEVBQTVCO0FBQ0Esa0NBQVksS0FBS2IsUUFBakIsRUFBMkJlLElBQTNCLENBQWlDZixRQUFELElBQWM7QUFDMUNBLFFBQUFBLFFBQVEsQ0FBQ2MsSUFBVCxDQUFjSixJQUFkO0FBQ0gsT0FGRDtBQUdBLFdBQUtNLFNBQUwsR0FBaUJELElBQWpCLENBQXNCRSxNQUFNLElBQUk7QUFDNUJQLFFBQUFBLElBQUksQ0FBQ1EsVUFBTCxDQUFnQkQsTUFBaEI7QUFDSCxPQUZEO0FBR0gsS0FSRCxNQVNLLElBQUlQLElBQUksWUFBWWxCLFVBQVUsQ0FBQzJCLEtBQS9CLEVBQXNDO0FBQ3ZDLFlBQU1DLE9BQU8sR0FBRyxJQUFJVCxtQkFBSixDQUFlLEtBQUtiLElBQXBCLEVBQTBCWSxJQUExQixDQUFoQjtBQUNBLFdBQUtELFFBQUwsQ0FBY1csT0FBZDtBQUNIO0FBQ0o7QUFFRDs7Ozs7OztBQUtNQyxFQUFBQSxXQUFOLENBQWtCWCxJQUFsQixFQUF3QjtBQUFBOztBQUFBO0FBQ3BCLFlBQU1ZLFdBQVcsU0FBUyw0QkFBWSxLQUFJLENBQUN0QixRQUFqQixDQUExQjtBQUVBc0IsTUFBQUEsV0FBVyxDQUFDQyxNQUFaLENBQW1CYixJQUFuQjtBQUVBLGFBQU9jLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQkgsV0FBVyxDQUFDSSxPQUFaLENBQW9CaEIsSUFBcEIsTUFBOEIsQ0FBQyxDQUEvQyxDQUFQO0FBTG9CO0FBTXZCOztBQWpFaUQ7O0FBb0V0RGlCLCtCQUFXQyxlQUFYLENBQTJCLENBQUNqQyxvQkFBRCxDQUEzQjs7ZUFDZUEsb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZVNwaW5hbFJlbGF0aW9uIGZyb20gXCIuL0Jhc2VTcGluYWxSZWxhdGlvblwiXG5pbXBvcnQgeyBTUElOQUxfUkVMQVRJT05fUFRSX0xTVF9UWVBFIH0gZnJvbSBcIi4vU3BpbmFsUmVsYXRpb25GYWN0b3J5XCJcbmltcG9ydCBTcGluYWxOb2RlIGZyb20gXCIuLi9Ob2Rlcy9TcGluYWxOb2RlXCJcbmltcG9ydCB7IHByb21pc2VMb2FkIH0gZnJvbSBcIi4uL1V0aWxpdGllc1wiO1xuaW1wb3J0IFNwaW5hbE5vZGVQb2ludGVyIGZyb20gXCIuLi9TcGluYWxOb2RlUG9pbnRlclwiO1xuaW1wb3J0IHNwaW5hbENvcmUgZnJvbSBcInNwaW5hbC1jb3JlLWNvbm5lY3RvcmpzXCI7XG5cbmNvbnN0IGdsb2JhbFR5cGUgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5jbGFzcyBTcGluYWxSZWxhdGlvblB0ckxzdCBleHRlbmRzIEJhc2VTcGluYWxSZWxhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5hZGRfYXR0cih7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV3IFNwaW5hbE5vZGVQb2ludGVyKG5ldyBnbG9iYWxUeXBlLkxzdCgpKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLmluZm8uYWRkX2F0dHIoXCJpZHNcIiwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0cmlldmUgYWxsIHRoZSBpZCBmcm9tIGNoaWxkcmVuIG9mIHRoZSByZWxhdGlvbiBhbmQgcmV0dXJuIHRoZW0gaW5zaWRlIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBjb250YWluaW5nIGFsbCB0aGUgY2hpbGRyZW4gaWRzIG9mIHRoZSByZWxhdGlvblxuICAgICAqL1xuICAgIGdldENoaWxkcmVuSWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIHJlbGF0aW9uXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxnbG9iYWxUeXBlLkxzdD59XG4gICAgICovXG4gICAgZ2V0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlTG9hZCh0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSByZWxhdGlvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVHlwZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gU1BJTkFMX1JFTEFUSU9OX1BUUl9MU1RfVFlQRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbm9kZSBhcyBjaGlsZCBvZiB0aGUgcmVsYXRpb24gaWYgbm9kZSBpcyBhIG1vZGVsIGNyZWF0ZSBhIG5vZGVcbiAgICAgKiBAcGFyYW0gbm9kZSB7U3BpbmFsTm9kZSB8IGdsb2JhbFR5cGUuTW9kZWx9XG4gICAgICovXG4gICAgYWRkQ2hpbGQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNwaW5hbE5vZGUgJiYgIXRoaXMuY2hpbGRyZW4uaW5mby5pZHMuY29udGFpbnMobm9kZS5nZXRJZCgpKSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5pbmZvLmlkcy5wdXNoKG5vZGUuZ2V0SWQoKSk7XG4gICAgICAgICAgICBwcm9taXNlTG9hZCh0aGlzLmNoaWxkcmVuKS50aGVuKChjaGlsZHJlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZ2V0UGFyZW50KCkudGhlbihwYXJlbnQgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuX2FkZFBhcmVudChwYXJlbnQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBnbG9iYWxUeXBlLk1vZGVsKSB7XG4gICAgICAgICAgICBjb25zdCB0bXBOb2RlID0gbmV3IFNwaW5hbE5vZGUodGhpcy5uYW1lLCBub2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQodG1wTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGNoaWxkIGZyb20gdGhlIHJlbGF0aW9uXG4gICAgICogQHBhcmFtIG5vZGUge1NwaW5hbE5vZGV9IGNoaWxkIG9mIHRoZSByZWxhdGlvblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbkxzdCA9IGF3YWl0IHByb21pc2VMb2FkKHRoaXMuY2hpbGRyZW4pO1xuXG4gICAgICAgIGNoaWxkcmVuTHN0LnJlbW92ZShub2RlKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoaWxkcmVuTHN0LmluZGV4T2Yobm9kZSkgPT09IC0xKTtcbiAgICB9XG59XG5cbnNwaW5hbENvcmUucmVnaXN0ZXJfbW9kZWxzKFtTcGluYWxSZWxhdGlvblB0ckxzdF0pO1xuZXhwb3J0IGRlZmF1bHQgU3BpbmFsUmVsYXRpb25QdHJMc3Q7XG4iXX0=