"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _spinalCoreConnectorjs = _interopRequireDefault(require("spinal-core-connectorjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const globalType = typeof window === "undefined" ? global : window;

class SpinalMap extends globalType.Model {
  constructor() {
    super();
  }
  /**
   * Sets the value for the key in the Map object. Returns the Map object
   * @param key
   * @param {*} value
   */


  setElement(key, value) {
    this.rem_attr(key);
    const attribute = {};
    attribute[key] = value;
    this.add_attr(attribute);
  }
  /**
   * Returns the value associated to the key, or undefined if there is none.
   * @param key
   * @returns {*}
   */


  getElement(key) {
    return this[key];
  }
  /**
   * Applies a function to each of the values in the map.
   * @param {Function} fun
   */


  forEach(fun) {
    for (let i = 0; i < this._attribute_names.length; i++) {
      let name = this._attribute_names[i];
      fun(this[name]);
    }
  }
  /**
   * Returns a boolean asserting whether a value has been associated to the key in the Map object or not.
   * @param key
   * @returns {boolean}
   */


  has(key) {
    return this._attribute_names.includes(key);
  }
  /**
   * Returns a boolean asserting whether the map contain any key
   * @returns {boolean}
   */


  hasKey() {
    return this._attribute_names.length > 0;
  }
  /**
   * Returns an array that contains the keys for each element in the Map object in insertion order.
   * @returns {Array}
   */


  keys() {
    return this._attribute_names;
  }
  /**
   * Deletes an element
   * @param key
   */


  delete(key) {
    this.rem_attr(key);
  }
  /**
   * Deletes all elements
   */


  clear() {
    let keys = this.keys();

    while (keys[0]) {
      this.delete(keys[0]);
    }
  }

}

_spinalCoreConnectorjs.default.register_models([SpinalMap]);

var _default = SpinalMap;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TcGluYWxNYXAuanMiXSwibmFtZXMiOlsiZ2xvYmFsVHlwZSIsIndpbmRvdyIsImdsb2JhbCIsIlNwaW5hbE1hcCIsIk1vZGVsIiwiY29uc3RydWN0b3IiLCJzZXRFbGVtZW50Iiwia2V5IiwidmFsdWUiLCJyZW1fYXR0ciIsImF0dHJpYnV0ZSIsImFkZF9hdHRyIiwiZ2V0RWxlbWVudCIsImZvckVhY2giLCJmdW4iLCJpIiwiX2F0dHJpYnV0ZV9uYW1lcyIsImxlbmd0aCIsIm5hbWUiLCJoYXMiLCJpbmNsdWRlcyIsImhhc0tleSIsImtleXMiLCJkZWxldGUiLCJjbGVhciIsInNwaW5hbENvcmUiLCJyZWdpc3Rlcl9tb2RlbHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUVBLE1BQU1BLFVBQVUsR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQyxNQUFoQyxHQUF5Q0QsTUFBNUQ7O0FBRUEsTUFBTUUsU0FBTixTQUF3QkgsVUFBVSxDQUFDSSxLQUFuQyxDQUF5QztBQUNyQ0MsRUFBQUEsV0FBVyxHQUFHO0FBQ1Y7QUFDSDtBQUVEOzs7Ozs7O0FBS0FDLEVBQUFBLFVBQVUsQ0FBQ0MsR0FBRCxFQUFNQyxLQUFOLEVBQWE7QUFDbkIsU0FBS0MsUUFBTCxDQUFjRixHQUFkO0FBQ0EsVUFBTUcsU0FBUyxHQUFHLEVBQWxCO0FBQ0FBLElBQUFBLFNBQVMsQ0FBQ0gsR0FBRCxDQUFULEdBQWlCQyxLQUFqQjtBQUVBLFNBQUtHLFFBQUwsQ0FBY0QsU0FBZDtBQUNIO0FBRUQ7Ozs7Ozs7QUFLQUUsRUFBQUEsVUFBVSxDQUFDTCxHQUFELEVBQU07QUFDWixXQUFPLEtBQUtBLEdBQUwsQ0FBUDtBQUNIO0FBRUQ7Ozs7OztBQUlBTSxFQUFBQSxPQUFPLENBQUNDLEdBQUQsRUFBTTtBQUNULFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLQyxnQkFBTCxDQUFzQkMsTUFBMUMsRUFBa0RGLENBQUMsRUFBbkQsRUFBdUQ7QUFDbkQsVUFBSUcsSUFBSSxHQUFHLEtBQUtGLGdCQUFMLENBQXNCRCxDQUF0QixDQUFYO0FBQ0FELE1BQUFBLEdBQUcsQ0FBQyxLQUFLSSxJQUFMLENBQUQsQ0FBSDtBQUNIO0FBQ0o7QUFFRDs7Ozs7OztBQUtBQyxFQUFBQSxHQUFHLENBQUNaLEdBQUQsRUFBTTtBQUNMLFdBQU8sS0FBS1MsZ0JBQUwsQ0FBc0JJLFFBQXRCLENBQStCYixHQUEvQixDQUFQO0FBQ0g7QUFFRDs7Ozs7O0FBSUFjLEVBQUFBLE1BQU0sR0FBRztBQUNMLFdBQU8sS0FBS0wsZ0JBQUwsQ0FBc0JDLE1BQXRCLEdBQStCLENBQXRDO0FBQ0g7QUFFRDs7Ozs7O0FBSUFLLEVBQUFBLElBQUksR0FBRztBQUNILFdBQU8sS0FBS04sZ0JBQVo7QUFDSDtBQUVEOzs7Ozs7QUFJQU8sRUFBQUEsTUFBTSxDQUFDaEIsR0FBRCxFQUFNO0FBQ1IsU0FBS0UsUUFBTCxDQUFjRixHQUFkO0FBQ0g7QUFFRDs7Ozs7QUFHQWlCLEVBQUFBLEtBQUssR0FBRztBQUNKLFFBQUlGLElBQUksR0FBRyxLQUFLQSxJQUFMLEVBQVg7O0FBRUEsV0FBT0EsSUFBSSxDQUFDLENBQUQsQ0FBWCxFQUFnQjtBQUNaLFdBQUtDLE1BQUwsQ0FBWUQsSUFBSSxDQUFDLENBQUQsQ0FBaEI7QUFDSDtBQUNKOztBQWhGb0M7O0FBbUZ6Q0csK0JBQVdDLGVBQVgsQ0FBMkIsQ0FBQ3ZCLFNBQUQsQ0FBM0I7O2VBQ2VBLFMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3BpbmFsQ29yZSBmcm9tIFwic3BpbmFsLWNvcmUtY29ubmVjdG9yanNcIjtcblxuY29uc3QgZ2xvYmFsVHlwZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbmNsYXNzIFNwaW5hbE1hcCBleHRlbmRzIGdsb2JhbFR5cGUuTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGUga2V5IGluIHRoZSBNYXAgb2JqZWN0LiBSZXR1cm5zIHRoZSBNYXAgb2JqZWN0XG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW1fYXR0cihrZXkpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSB7fTtcbiAgICAgICAgYXR0cmlidXRlW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLmFkZF9hdHRyKGF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0RWxlbWVudChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBvZiB0aGUgdmFsdWVzIGluIHRoZSBtYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuXG4gICAgICovXG4gICAgZm9yRWFjaChmdW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVfbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdGhpcy5fYXR0cmlidXRlX25hbWVzW2ldO1xuICAgICAgICAgICAgZnVuKHRoaXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gYXNzZXJ0aW5nIHdoZXRoZXIgYSB2YWx1ZSBoYXMgYmVlbiBhc3NvY2lhdGVkIHRvIHRoZSBrZXkgaW4gdGhlIE1hcCBvYmplY3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVfbmFtZXMuaW5jbHVkZXMoa2V5KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGFzc2VydGluZyB3aGV0aGVyIHRoZSBtYXAgY29udGFpbiBhbnkga2V5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlX25hbWVzLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIE1hcCBvYmplY3QgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlX25hbWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHRoaXMucmVtX2F0dHIoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFsbCBlbGVtZW50c1xuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBsZXQga2V5cyA9IHRoaXMua2V5cygpO1xuXG4gICAgICAgIHdoaWxlIChrZXlzWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrZXlzWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuc3BpbmFsQ29yZS5yZWdpc3Rlcl9tb2RlbHMoW1NwaW5hbE1hcF0pO1xuZXhwb3J0IGRlZmF1bHQgU3BpbmFsTWFwO1xuIl19